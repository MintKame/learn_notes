
## 121. 买卖股票的最佳时机

[力扣题目链接](https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/)

给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格。

你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票。设计一个算法来计算你所能获取的最大利润。

返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 0 。

示例 1：   
输入：[7,1,5,3,6,4]   
输出：5    
解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。

示例 2：   
输入：prices = [7,6,4,3,1]  
输出：0    
解释：在这种情况下, 没有交易完成, 所以最大利润为 0。

### 暴力

最直观的想法，就是暴力，找最优间距了。

```CPP
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int result = 0;
        for (int i = 0; i < prices.size(); i++) {
            for (int j = i + 1; j < prices.size(); j++){
                result = max(result, prices[j] - prices[i]);
            }
        }
        return result;
    }
};
```

* 时间复杂度：O(n^2) 超时
* 空间复杂度：O(1)

### 贪心

因为股票就买卖一次，

取最左最小值，取最右最大值，那么得到的差值就是最大利润。 

```CPP
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int low = INT_MAX;
        int result = 0;
        for (int i = 0; i < prices.size(); i++) {
            low = min(low, prices[i]);  // 取最左最小价格
            result = max(result, prices[i] - low); // 直接取最大区间利润
        }
        return result;
    }
};
```

* 时间复杂度：$O(n)$
* 空间复杂度：$O(1) 

### dp

+ 交易数 = 买 + 卖

+ 对比

  | 题号 | 最多交易 | 要求              | 状态数                       |      |
  | ---- | -------- | ----------------- | ---------------------------- | ---- |
  | 121  | 1        |                   | 2 持有、不持有               |      |
  | 122  | 不限     |                   | 2 持有、不持有               |      |
  | 123  | 2        |                   | 持有 * 交易次数              |      |
  | 188  | k        |                   | 持有 * 交易次数              |      |
  | 309  | 不限     | 冷冻期1天         | 持有、卖出、冷冻期、非冷冻期 |      |
  | 714  | 不限     | 每笔交易手续费fee | 2 持有、不持有               |      |

```java
class Solution32 {
    public int maxProfit(int[] prices) {
        // 1.dp[i][0] 第i天 不持有，能获得最大利润 （注意：不持有，不是第i天卖出）
        //   dp[i][1] 第i天 持有，  能获得最大利润 （注意：持有，不是第i天买入）
        // 			  只买卖一次。那么第i天买入就是 -prices[i]， 是一个负数
        int[][] dp = new int[prices.length][2];
        // 2.递推: dp[i][0] = max(dp[i-1][0], dp[i-1][1] + prices[i])
        //                   [0..i-1]天不持有 / 第i-1天持有，第i天卖出
        //         dp[i][1] = max(dp[i-1][1], -prices[i])
        //                   [0..i-1]天持有  / 第i天买入（不用+dp[i-1][0]，因已卖出后不可再买入）
        // 3.初始化：
        dp[0][0] = 0; 				// 第0天不持有
        dp[0][1] = -prices[0];		// 第0天持有，需要在第0天买入
        // 4.遍历：
        for(int i = 1; i < prices.length; i++){
            dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i-1][1], - prices[i]);    
        }
        return dp[prices.length - 1][0];
    }
}
```

时间复杂度：$O(n)$

空间复杂度：$O(n)$

5. 举例推导dp数组

   `dp[5][1]`就是最终结果。

   为什么不是`dp[5][0]`？

   **因为本题中不持有股票状态所得金钱，一定比持有股票状态得的多**

   ![121.买卖股票的最佳时机](https://img-blog.csdnimg.cn/20210224225642465.png)

### dp，滚动数组

dp[i]只依赖于dp[i - 1]的状态

只需要记录 当前天的dp状态和前一天的dp状态， 节省空间

```CPP
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        vector<vector<int>> dp(2, vector<int>(2)); 
        // 注意这里只开辟了一个2 * 2大小的二维数组
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i % 2][0] = max(dp[(i - 1) % 2][0], -prices[i]);
            dp[i % 2][1] = max(dp[(i - 1) % 2][1], prices[i] + dp[(i - 1) % 2][0]);
        }
        return dp[(len - 1) % 2][1];
    }
};
```

* 时间复杂度：$O(n)$
* 空间复杂度：$O(1)$

 

 