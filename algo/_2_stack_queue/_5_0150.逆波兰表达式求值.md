# 150. 逆波兰表达式求值

 https://leetcode-cn.com/problems/evaluate-reverse-polish-notation/ 

根据 逆波兰表示法，求表达式的值。

有效的运算符包括 + ,  - ,  *  ,  / 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

说明：

整数除法只保留整数部分。
给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。


示例 1：
* 输入: ["2", "1", "+", "3", " * "]
* 输出: 9
* 解释: 该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9

示例 2：
* 输入: ["4", "13", "5", "/", "+"]
* 输出: 6
* 解释: 该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6

示例 3：
* 输入: ["10", "6", "9", "3", "+", "-11", " * ", "/", " * ", "17", "+", "5", "+"]

* 输出: 22

* 解释:该算式转化为常见的中缀算术表达式为：

  ```
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5       
  = ((10 * (6 / (12 * -11))) + 17) + 5       
  = ((10 * (6 / -132)) + 17) + 5     
  = ((10 * 0) + 17) + 5     
  = (0 + 17) + 5    
  = 17 + 5    
  = 22    
  ```


逆波兰表达式：是一种后缀表达式，所谓后缀就是指算符写在后面。

平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。

该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。

逆波兰表达式主要有以下两个优点：

* 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。

* 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。

# 思路

+ 拓展：**栈与递归 可以转换**。本题，**逆波兰表达式相当于是二叉树中的后序遍历**。 大家可以把运算符作为中间节点，按照后序遍历的规则画出一个二叉树。

+ 本题每一个子表达式要得出一个结果，这个结果再进行运算，那么**类似相邻字符串消除的过程，和[1047.删除字符串中的所有相邻重复项](https://programmercarl.com/1047.删除字符串中的所有相邻重复项.html)非常像。**
+ 中缀表达式符合我们的习惯，但对计算机不友好。
  + 例如：4 + 13 / 5，计算机从左到右去扫描，扫到13，还要判断13后面是什么运算，比较一下优先级，然后13还和后面的5做运算，做完运算之后，还要向前回退到 4 的位置，继续做加法
  + 后缀表达式。利用栈顺序处理，不考虑优先级。也不用回退 

 


![150.逆波兰表达式求值](https://code-thinking.cdn.bcebos.com/gifs/150.逆波兰表达式求值.gif)

 

```Java
 public class Solution5 {
    public int evalRPN(String[] tokens) {
        final Stack<Integer> stack = new Stack<>();
        // 数字入栈，符号则出栈2个数，结果入栈
        for (String token : tokens) {
            // 数字
            //! 不可通过第一个字符判断是否数字，maybe 负数
            if (Character.isDigit(token.charAt(token.length()-1))) {
                stack.push(Integer.valueOf(token));
            } else { // 符号
                int b = stack.pop();
                int a = stack.pop(); // 注意ab顺序
                int result = 0;
                switch (token){
                    case "+":
                        result = a + b;
                        break;
                    case "-":
                        result = a - b;
                        break;
                    case "*":
                        result = a * b;
                        break;
                    case "/":
                        result = a / b;
                        break;
                }
                stack.push(result);
            }
        }
        return stack.pop(); // 最终只剩一个数字（即结果）
    }
}
```



