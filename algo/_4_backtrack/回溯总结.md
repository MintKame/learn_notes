* 如何理解回溯法的搜索过程？
* 什么时候用startIndex，什么时候不用？ 
* 如何去重？如何理解“树枝去重”与“树层去重”？ 
* 去重的几种方法？
* 如何理解二维递归？ 

# 组合问题 

## 组合问题 

用递归控制for循环嵌套的数量！

![77.组合1](https://img-blog.csdnimg.cn/20201118152928844.png)

**for循环横向遍历，递归纵向遍历，回溯不断调整结果集**，这个理念贯穿整个回溯法系列，也是我做了很多回溯的题目，不断摸索其规律才总结出来的。

只有剪枝一种方法 

![77.组合4](https://img-blog.csdnimg.cn/20201118153133458.png)

 for循环在寻找起点的时候要有一个范围，如果这个起点到集合终止之间的元素已经不够题目要求的k个元素了，就没有必要搜索了 

**在for循环上做剪枝操作是回溯法剪枝的常见套路！**  


## 组合总和

### 组合总和（一）

在[回溯算法：求组合总和！](https://programmercarl.com/0216.组合总和III.html)中，相当于 [回溯算法：求组合问题！](https://programmercarl.com/0077.组合.html)加了一个元素总和的限制。


![216.组合总和III](https://img-blog.csdnimg.cn/20201118201921245.png)

1. **已选元素总和如果已经大于n（题中要求的和）了，那么往后遍历就没有意义了，直接剪掉**， 

2. [回溯算法：组合问题再剪剪枝](https://programmercarl.com/0077.组合优化.html)中提到的，对for循环选择的起始范围的剪枝。

   所以剪枝的代码可以在for循环加上 `i <= 9 - (k - path.size()) + 1` 的限制！

![216.组合总和III1](https://img-blog.csdnimg.cn/20201118202038240.png)

 

### 组合总和（二）

 本题没有数量要求，可以无限重复，但是有总和的限制，所以间接的也是有个数的限制。

错：可以重复选择元素，就把startIndex去掉了。导致结果重复

**本题还需要startIndex来控制for循环的起始位置，对于组合问题，什么时候需要startIndex呢？**

我举过例子，如果是一个集合来求组合的话，就需要startIndex，例如：[回溯算法：求组合问题！](https://programmercarl.com/0077.组合.html)，[回溯算法：求组合总和！](https://programmercarl.com/0216.组合总和III.html)。

如果是多个集合取组合，各个集合之间相互不影响，那么就不用startIndex，例如：[回溯算法：电话号码的字母组合](https://programmercarl.com/0017.电话号码的字母组合.html)

**注意以上我只是说求组合的情况，如果是排列问题，又是另一套分析的套路**。

 此处重复选择的实现：startIndex不用+1，st下次递归可选同一个数

![39.组合总和](https://img-blog.csdnimg.cn/20201118152521990.png)

最后还给出了本题的剪枝优化，如下：

```cpp
for (int i = startIndex; i < candidates.size() && sum + candidates[i] <= target; i++)
```

![39.组合总和1](https://img-blog.csdnimg.cn/20201118202115929.png)


### 组合总和（三）

在[回溯算法：求组合总和（三）](https://programmercarl.com/0040.组合总和II.html)中集合元素会有重复，但要求解集不能包含重复的组合。

 “使用过”在这个树形结构上是有两个维度的，一个维度是同一树枝上“使用过”，一个维度是同一树层上“使用过”。**没有理解这两个层面上的“使用过” 是造成大家没有彻底理解去重的根本原因**。

![40.组合总和II1](https://img-blog.csdnimg.cn/2020111820220675.png)

我在图中将used的变化用橘黄色标注上，**可以看出在candidates[i] == candidates[i - 1]相同的情况下：**

* used[i - 1] == true，说明同一树枝candidates[i - 1]使用过
* used[i - 1] == false，说明同一树层candidates[i - 1]使用过

 

## 多个集合求组合

 for循环，可不像是在 [回溯算法：求组合问题！](https://programmercarl.com/0077.组合.html)和[回溯算法：求组合总和！](https://programmercarl.com/0216.组合总和III.html)中从startIndex开始遍历的。

**因为本题每一个数字代表的是不同集合，也就是求不同集合之间的组合，而[回溯算法：求组合问题！](https://programmercarl.com/0077.组合.html)和[回溯算法：求组合总和！](https://programmercarl.com/0216.组合总和III.html)都是是求同一个集合中的组合！ 

![17. 电话号码的字母组合](https://img-blog.csdnimg.cn/20201118202335724.png)

 

# 切割问题

 

* 切割问题其实类似组合问题
* 如何模拟那些切割线
* 切割问题中递归如何终止
* 在递归循环中如何截取子串
* 如何判断回文

  

![131.分割回文串](https://img-blog.csdnimg.cn/20201118202448642.png)


# 子集问题 

## 子集问题（一）

 ，**在树形结构中子集问题是要收集所有节点的结果，而组合问题是收集叶子节点的结果**。

 

![78.子集](https://img-blog.csdnimg.cn/20201118202544339.png)

 

**本题其实可以不需要加终止条件**，因为startIndex >= nums.size()，本层for循环本来也结束了，本来我们就要遍历整棵树。

不会无限递归？因为每次递归的下一层就是从i+1开始的。

如果要写终止条件，注意：`result.push_back(path);`要放在终止条件的上面，如下：

```
result.push_back(path); // 收集子集，要放在终止添加的上面，否则会漏掉结果
if (startIndex >= nums.size()) { // 终止条件可以不加
    return;
}
```

## 子集问题（二）

 [回溯算法：求子集问题！](https://programmercarl.com/0078.子集.html)的基础上加上了去重，去重我们在[回溯算法：求组合总和（三）](https://programmercarl.com/0040.组合总和II.html)也讲过了 

![90.子集II](https://img-blog.csdnimg.cn/2020111217110449.png)

## 递增子序列


![491. 递增子序列1](https://img-blog.csdnimg.cn/20201112170832333.png)




**[回溯算法：求子集问题（二）](https://programmercarl.com/0090.子集II.html)也可以使用set针对同一父节点本层去重，但子集问题一定要排序，为什么呢？** 

我用没有排序的集合{2,1,2,2}来举个例子画一个图，如下：

![90.子集II2](https://img-blog.csdnimg.cn/2020111316440479.png)

 

# 排列问题

## 排列问题（一）

有序的，也就是说 [1,2] 和 [2,1] 是两个集合  

元素1在[1,2]中已经使用过了，但是在[2,1]中还要在使用一次1，所以处理排列问题就不用使用startIndex了。

如图：

![46.全排列](https://img-blog.csdnimg.cn/20201112170304979.png)

**大家此时可以感受出排列问题的不同：**

* 每层都是从0开始搜索而不是startIndex
* 需要used数组记录path里都放了哪些元素了

## 排列问题（二）

排列问题也要去重了，在[回溯算法：排列问题（二）](https://programmercarl.com/0047.全排列II.html)中又一次强调了“树层去重”和“树枝去重”。

 

![47.全排列II1](https://img-blog.csdnimg.cn/20201112171930470.png)

**这道题目神奇的地方就是used[i - 1] == false也可以，used[i - 1] == true也可以！**

我就用输入: [1,1,1] 来举一个例子。

树层上去重(used[i - 1] == false)，的树形结构如下：

![47.全排列II2.png](https://img-blog.csdnimg.cn/20201112172230434.png)

树枝上去重（used[i - 1] == true）的树型结构如下：

![47.全排列II3](https://img-blog.csdnimg.cn/20201112172327967.png)

**可以清晰的看到使用(used[i - 1] == false)，即树层去重，效率更高！**

本题used数组即是记录path里都放了哪些元素，同时也用来去重，一举两得。

# 去重问题 

以上我都是统一使用used数组来去重的，其实使用set也可以用来去重！

在[本周小结！（回溯算法系列三）续集](https://programmercarl.com/回溯算法去重问题的另一种写法.html)中给出了子集、组合、排列问题使用set来去重的解法以及具体代码，并纠正一些同学的常见错误写法。 

 

# 重新安排行程（图论拓展）

之前说过，有递归的地方就有回溯，深度优先搜索也是用递归来实现的，所以往往伴随着回溯。

在[回溯算法：重新安排行程](https://programmercarl.com/0332.重新安排行程.html)其实也算是图论里深搜的题目，但是我用回溯法的套路来讲解这道题目 

以输入：[["JFK", "KUL"], ["JFK", "NRT"], ["NRT", "JFK"]为例，抽象为树形结构如下：

![](https://img-blog.csdnimg.cn/2020111518065555.png)

 

**如果单纯的回溯搜索（深搜）并不难，难还难在容器的选择和使用上！**

本题其实是一道深度优先搜索的题目，但是我完全使用回溯法的思路来讲解这道题题目，**算是给大家拓展一下思维方式，其实深搜和回溯也是分不开的，毕竟最终都是用递归**。


# 棋盘问题 

## N皇后问题 

下面我用一个3 * 3 的棋盘，将搜索过程抽象为一棵树，如图：

![51.N皇后](https://img-blog.csdnimg.cn/20201118225433127.png)

二维矩阵中矩阵的高就是这棵树的高度，矩阵的宽就是树形结构中每一个节点的宽度。

那么我们用皇后们的约束条件，来回溯搜索这棵树，**只要搜索到了树的叶子节点，说明就找到了皇后们的合理位置了**。 

 

**这里我明确给出了棋盘的宽度就是for循环的长度，递归的深度就是棋盘的高度，这样就可以套进回溯法的模板里了**。 

## 解数独问题

 只要理解 “二维递归”这个过程，其实发现就没那么难了。

大家已经跟着「代码随想录」刷过了如下回溯法题目，例如：[77.组合（组合问题）](https://programmercarl.com/0077.组合.html)，[131.分割回文串（分割问题）](https://programmercarl.com/0131.分割回文串.html)，[78.子集（子集问题）](https://programmercarl.com/0078.子集.html)，[46.全排列（排列问题）](https://programmercarl.com/0046.全排列.html)，以及[51.N皇后（N皇后问题）](https://programmercarl.com/0051.N皇后.html)，其实这些题目都是一维递归。

其中[N皇后问题](https://programmercarl.com/0051.N皇后.html)是因为每一行每一列只放一个皇后，只需要一层for循环遍历列，递归来遍历行，然后一行一列确定皇后的唯一位置。

 本题中棋盘的每一个位置都要放一个数字，并检查合法，解数独的树形结构要比N皇后更宽更深。

 

![37.解数独](https://img-blog.csdnimg.cn/2020111720451790.png)

 所以我在[回溯算法：解数独](https://programmercarl.com/0037.解数独.html)中开篇就提到了二维递归， 





 

