

## 应用

+ 应用：快速判断一个元素是否出现在集合里。

+ 例：查一个名字是否在这所学校里。

  枚举时间复杂度是O(n)，哈希表O(1)

  需要：初始化把学生的名字都存在哈希表里，

  查询：hash function将姓名映射到哈希表索引，通过查询索引下标快速知道这位同学是否在这所学校里了。

+ 哈希**空间换时间**，因为要使用额外的数组，set或者是map来存放数据，才能实现快速的查找。

+ 对比 

  +  效率：与数组相比，占用空间大（维护红黑树或者哈希表），速度慢（hash函数：key的值->索引）

|          | 数组           | set                           | map                           |
| -------- | -------------- | ----------------------------- | ----------------------------- |
| key范围  | 集中且大小有限 | key分散或无限，需要映射为索引 | key分散或无限，需要映射为索引 |
| 附加信息 | 可             | 只能放key                     | 可                            |
| 去重     | no             | yes                           | yes                           |



## 索引

+ 数组计数：1，2，7

+ set计数：3，4（去重）

+ map计数：

  + 5（key为被查找的值，value为索引）
  + 6（value为出现次数）
+ 双指针：8，9（若哈希，去重有多细节。）



## 哈希表

+ 什么是 哈希表，散列表（Hash table）。

> 哈希表是根据关键码的值而直接进行访问的数据结构。

数组就是一张哈希表：哈希表中关键码就是数组的下标，然后通过下标直接访问数组中的元素，如图：

![哈希表1](https://img-blog.csdnimg.cn/20210104234805168.png)

## 

## 哈希函数

哈希函数，通过hashCode把值转化为数值（索引下标）。

![哈希表2](https://img-blog.csdnimg.cn/2021010423484818.png)

+ 如果hashCode得到的数值大于 哈希表的大小

  为保证映射的索引落在哈希表上，再对数值取模

+ 哈希表是一个数组。如果学生的数量大于哈希表的大小

  就算哈希函数计算的再均匀，也避免不了会有几位名字同时映射到哈希表 同一个索引

  

## 哈希碰撞

处理有多个key映射到相同索引上

小李和小王都映射到了索引下标 1 的位置，**这一现象叫做哈希碰撞**。

有两种解决方法。

![哈希表3](https://img-blog.csdnimg.cn/2021010423494884.png)



### 拉链法

在索引1发生冲突，发生冲突的元素都被存在链表中。 

![哈希表4](https://img-blog.csdnimg.cn/20210104235015226.png)

（数据规模是dataSize， 哈希表的大小为tableSize）

+ 要选择适当哈希表大小

  这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。

### 线性探测法

依靠哈希表中的空位来解决碰撞问题。一定要保证tableSize大于dataSize。 

例如冲突的位置，放了小李，那么就向下找一个空位放置小王的信息。所以要求tableSize一定要大于dataSize ，要不然哈希表上就没有空置的位置来存放 冲突的数据了。如图所示：

![哈希表5](https://img-blog.csdnimg.cn/20210104235109950.png)

 

## 常见的三种哈希结构

使用哈希法来解决问题，要选择如下三种数据结构。

* 数组
* set （集合）
* map (映射)

在C++中，set 和 map 分别提供以下三种数据结构，其底层实现以及优劣如下表：

|集合 |底层实现 | 是否有序 |数值是否可以重复 | 能否更改数值|查询效率 |增删效率|
|---|---| --- |---| --- | --- | ---|
|std::set |红黑树 |有序 |否 |否 | $O(\log n)$|$O(\log n)$ |
|std::multiset | 红黑树|有序 |是 | 否| $O(\log n)$ |$O(\log n)$ |
|std::unordered_set |哈希表 |无序 |否 |否 |$O(1)$ | $O(1)$|

std::unordered_set底层实现为哈希表，

std::set 和std::multiset 的底层实现是红黑树，红黑树是一种平衡二叉搜索树，所以key值是有序的，但key不可以修改，改动key值会导致整棵树的错乱，所以只能删除和增加。

|映射 |底层实现 | 是否有序 |数值是否可以重复 | 能否更改数值|查询效率 |增删效率|
|---|---| --- |---| --- | --- | ---|
|std::map |红黑树 |key有序 |key不可重复 |key不可修改 | $O(\log n)$|$O(\log n)$ |
|std::multimap | 红黑树|key有序 | key可重复 | key不可修改|$O(\log n)$ |$O(\log n)$ |
|std::unordered_map |哈希表 | key无序 |key不可重复 |key不可修改 |$O(1)$ | $O(1)$|

std::unordered_map 底层实现为哈希表，std::map 和std::multimap 的底层实现是红黑树。同理，std::map 和std::multimap 的key也是有序的（这个问题也经常作为面试题，考察对语言容器底层的理解）。

当我们要使用集合来解决哈希问题的时候，优先使用unordered_set，因为它的查询和增删效率是最优的，如果需要集合是有序的，那么就用set，如果要求不仅有序还要有重复数据的话，那么就用multiset。

那么再来看一下map ，在map 是一个key value 的数据结构，map中，对key是有限制，对value没有限制的，因为key的存储方式使用红黑树实现的。

其他语言例如：java里的HashMap ，TreeMap 都是一样的原理。可以灵活贯通。

虽然std::set、std::multiset 的底层实现是红黑树，不是哈希表，但是std::set、std::multiset 依然使用哈希函数来做映射，只不过底层的符号表使用了红黑树来存储数据，所以使用这些数据结构来解决映射问题的方法，我们依然称之为哈希法。 map也是一样的道理。

这里在说一下，一些C++的经典书籍上 例如STL源码剖析，说到了hash_set hash_map，这个与unordered_set，unordered_map又有什么关系呢？

实际上功能都是一样一样的， 但是unordered_set在C++11的时候被引入标准库了，而hash_set并没有，所以建议还是使用unordered_set比较好，这就好比一个是官方认证的，hash_set，hash_map 是C++11标准之前民间高手自发造的轮子。

![哈希表6](https://img-blog.csdnimg.cn/20210104235134572.png)

 
