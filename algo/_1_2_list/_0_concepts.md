+ 索引
+ 虚拟头节点：1，2，5
  + 解决：操作当前节点必须找前一个节点才能操作。头结点没有前一个节点。要单独处理
+ 改变局部指针：1，3，4
+ 双指针：3，4，5，6，7
+ 找环及环入口：7
 
# 链表的类型

## 单链表

![链表1](https://img-blog.csdnimg.cn/20200806194529815.png)

## 双链表

单链表中的节点只能指向节点的下一个节点。

双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。

既可以向前查询也可以向后查询。
![链表2](https://img-blog.csdnimg.cn/20200806194559317.png)

## 循环链表

链表首尾相连。

可以用来解决约瑟夫环问题。

![链表4](https://img-blog.csdnimg.cn/20200806194629603.png)


# 链表的存储方式

链表是通过指针域的指针链接在内存中各个节点。

所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

![链表3](https://img-blog.csdnimg.cn/20200806194613920.png)

这个链表起始节点为2， 终止节点为7，  各个节点分布在内存个不同地址空间上，通过指针串联在一起。

# 链表的定义

C/C++的定义链表节点方式，如下所示：

```cpp
// 单链表
struct ListNode {
    int val;  // 节点上存储的元素
    ListNode *next;  // 指向下一个节点的指针
    ListNode(int x) : val(x), next(NULL) {}  // 节点的构造函数
};
```


Java：

```java
public class ListNode {
    // 结点的值
    int val;

    // 下一个结点
    ListNode next; 
}
```



不定义构造函数，java默认生成一个构造函数：不初始化任何成员变量。

通过自定义构造函数初始化节点：

```cpp
ListNode* head = new ListNode(5);
```

使用默认构造函数初始化节点：

```cpp
ListNode* head = new ListNode();
head->val = 5;
```

# 链表的操作

## 删除节点

删除D节点，如图所示：

![链表-删除节点](https://img-blog.csdnimg.cn/20200806195114541.png)

只要将C节点的next指针 指向E节点就可以了。

C++：手动释放D节点

Java、Python等有内存回收机制，不用手动释放。只要不可达，自动删除。节点的next不需要置空

## 添加节点

![链表-添加节点](https://img-blog.csdnimg.cn/20200806195134331.png)

增删都是O(1)操作，也不会影响到其他节点。

注意：删第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。

# 性能分析

![链表-链表与数据性能对比](https://img-blog.csdnimg.cn/20200806195200276.png)

数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。

链表的长度可以是不固定的，并且可以动态增删

 
