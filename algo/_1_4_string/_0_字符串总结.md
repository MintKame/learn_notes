+ 索引

  替换：3

  翻转：1245 

  kmp：68

  双指针：1234

  345都用了一些技巧，不用新空间。但由于java不能给原字符串的数组扩容（底层是创建了新字符串），因此 实际上 3 需要空间O(n)




# 要不要用库函数 

[344.反转字符串](https://programmercarl.com/0344.反转字符串.html)

建议**题目关键的部分直接用库函数就可以解决，不要用库函数。**

**如果库函数仅是 解题的一小部分，且已清楚内部实现原理的话，可以使用库函数。**

# 双指针法

[344.反转字符串](https://programmercarl.com/0344.反转字符串.html) ，双指针法实现了反转字符串 

[字符串：替换空格](https://programmercarl.com/剑指Offer05.替换空格.html)，先扩容，再双指针填入，时间复杂度O(n)

[151.翻转字符串里的单词](https://programmercarl.com/0151.翻转字符串里的单词.html)，先删除空格，O(n)的时间复杂度

# 反转

  [344.反转字符串](https://programmercarl.com/0344.反转字符串.html)，双指针法反转一个字符串 

[541. 反转字符串II](https://programmercarl.com/0541.反转字符串II.html)，反转加条件，固定规律一段一段处理字符串

 翻转整体+翻转局部：4，5

# KMP 

主要思想是**当出现字符串不匹配时，可以知道一部分之前已经匹配的文本内容，可以利用这些信息避免从头再去做匹配了。**

KMP的精髓所在就是前缀表，在[KMP精讲](https://programmercarl.com/0028.实现strStr.html)中提到了，什么是KMP，什么是前缀表，以及为什么要用前缀表。

前缀表：起始位置到下标i之前（包括i）的子串中，有多大长度的相同前缀后缀。

那么使用KMP可以解决两类经典问题：

1. 匹配问题：[28. 实现 strStr()](https://programmercarl.com/0028.实现strStr.html)
2. 重复子串问题：[459.重复的子字符串](https://programmercarl.com/0459.重复的子字符串.html)

再一次强调了什么是前缀，什么是后缀，什么又是最长相等前后缀。

前缀：指不包含最后一个字符的所有以第一个字符开头的连续子串。

后缀：指不包含第一个字符的所有以最后一个字符结尾的连续子串。

然后**针对前缀表到底要不要减一，这其实是不同KMP实现的方式**，我们在[KMP精讲](https://programmercarl.com/0028.实现strStr.html)中针对之前两个问题，分别给出了两个不同版本的的KMP实现。

其中主要**理解j=next[x]这一步最为关键！**

 

 
