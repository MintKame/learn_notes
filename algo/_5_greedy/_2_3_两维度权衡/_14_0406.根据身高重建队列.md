# 406.根据身高重建队列

[力扣题目链接](https://leetcode-cn.com/problems/queue-reconstruction-by-height/)

假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

示例 1：
* 输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
* 输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
* 解释：
    * 编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
    * 编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
    * 编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
    * 编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
    * 编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
    * 编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
    * 因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。

示例 2：
* 输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
* 输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]

提示：

* 1 <= people.length <= 2000
* 0 <= hi <= 10^6
* 0 <= ki < people.length

题目数据确保队列可以被重建

## 贪心1

+ 本题有两个维度，h和k，看到这种题目一定要想如何确定一个维度，然后按另一个维度重新排列。 

  **如果两个维度一起考虑一定会顾此失彼**。 


1. 排序：身高 **大到小**，\>=人数 **小到大**
   [[7,0], [7,1], [6,1], [5,0], [5,2]，[4,4]]

2. 遍历，插入当前人，直接根据 >=人数 确定在新队列位置

   插入[7,0]：[[7,0]]

   插入[7,1]：[[7,0],[7,1]]

   插入[6,1]：[[7,0],[6,1],[7,1]]

   插入[5,0]：[[5,0],[7,0],[6,1],[7,1]]

   插入[5,2]：[[5,0],[7,0],[5,2],[6,1],[7,1]]

   插入[4,4]：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 

+ why：优先排h

  如果按k 从小到大排，会发现k的排列并不符合条件，身高也不符合条件，两个维度哪一个都没确定下来。

+ why：插入当前人时，直接根据 >=人数 确定在新队列位置

  排序 身高大到小，遍历当前人时，队列中全是 >=的人，

  so 插入当前人，直接根据 >=人数 插入位置，st 满足第二维度 k

+ 如何确保，插入当前人，不改变已插入人的属性

  由于：排序身高  大到小，>=人数 小到大

  对于 >的, 不影响人数

  对于 =的, 其>=人数 少于 当前人, 当前人插入位置一定在他后面

  + 否则：h小到大 

    先插矮人，再插高人。

    若 高人插矮人前面，st矮人的 第二维度不再满足

  + 否则：h大到小，k大到小 

    等高的人，先插k大的，再插k小的。

    若 等高的 k小的插在 k大的前面，st k大的 第二维度不再满足

+ **局部最优：优先高的插入k处。每次插入满足队列属性**

  **全局最优：最后都做完插入操作，整个队列满足题目队列属性**

```java
public class Solution14 {
    public int[][] reconstructQueue(int[][] people) {
        // 排序 （身高，>=人数） 
        Arrays.sort(people, new Comparator<int[]>() {
            @Override
            public int compare(int[] o1, int[] o2) {
                if (o1[0] != o2[0]) return o2[0] - o1[0]; 
                return o1[1] - o2[1]; 
            }
        });
        // 逐个插入合适位置，以第二个属性为下标处
        LinkedList<int[]> list = new LinkedList<>();
        for (int i = 0; i < people.length; i++) {
            list.add(people[i][1], people[i]);
        }
        return list.toArray(new int[people.length][]); //! list -> arr
    } 
} 
```
* 时间复杂度：O(n*log n + n^2)
* 空间复杂度：O(n)

  

## 贪心2

```java
public class Solution14 {
    public int[][] reconstructQueue1(int[][] people) {
        Arrays.sort(people, new Comparator<int[]>(){ // 矮高排序
            public int compare(int[] a1, int[] a2){
                return a1[0] - a2[0];
            }
        });
        int[][] result = new int[people.length][]; // 存新队列
        // 遍历所有人：处理当前最矮，放入新位置
        for(int i = 0; i < people.length; i++){
            int cnt = people[i][1]; // 不矮于他的人数
            int pos = 0; // 新位置
            // 因为是当前最矮.空位置一定 不矮于他, 已填入则需判断 是否等高
            while(cnt > 0){
                if(result[pos] == null || result[pos][0] >= people[i][0]){ // 不矮于他
                    cnt--;
                }
                pos++;
            }
            // 若pos已经有人则跳过
            while(result[pos] != null) pos++;
            result[pos] = people[i];
        }
        return result;
    }  
}
```